---
title: "Introduction to vtree 2.2.3"
author: "Nick Barrowman"
date: '`r strftime(Sys.time(),format="%d-%b-%Y at %H:%M")`'
output:
  rmarkdown::html_vignette:
    css: vtreeVignette.css
    toc: true
    toc_depth: '2'
vignette: >
  %\VignetteIndexEntry{Introduction to vtree}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
suppressMessages(library(ggplot2))
library(vtree)
options(width=90)
```


# Introduction

`vtree` is a flexible tool for drawing *variable trees* &mdash;
diagrams that display information about nested subsets of a data frame.
`vtree` automatically produces these diagrams and labels them with
counts, percentages, and other summaries.
`vtree` can be used interactively to explore a data set and
can also be used to produce customized figures for reports and publications.

## Some examples

*Subsets* play an important role in almost any data analysis.
Imagine a data set of countries,
with variables named `population`, `continent`, `landlocked`,
and a variety of other variables representing economic and political characteristics.
We might wish to examine subsets of the data set based on the `continent` variable.
Within each of these subsets,
we might wish to examine *nested* subsets based on the `population` variable,
for example, countries with populations under 30 million and over 30 million.
We might continue to a third level of nesting based on the `landlocked` variable.
Nested subsets help us to answer questions like the following:
*Among African countries with a population over 30 million, what percentage are landlocked?*
The variable tree below answers this question:

```{r, echo=FALSE}
df <- build.data.frame(
  c("continent","population","landlocked"),
  list("Africa","Over 30 million","landlocked",2),
  list("Africa","Over 30 million","not landlocked",12),
  list("Africa","Under 30 million","landlocked",14),
  list("Africa","Under 30 million","not landlocked",26))
```

`r vtree(df,"continent population landlocked",showroot=FALSE,pxwidth=1000)`

Even in simple situations like this,
it can be a chore to keep track of nested subsets and to calculate percentages.
And as the number of subsetting variables increases,
the number of nested subsets grows rapidly.
When there are missing values in the data set,
the task becomes even more complicated.
For these reasons, it is best not to perform nested subsetting by hand.

Nested subsets arise in many situations.
Consider, for example, flow diagrams for clinical studies.
In a typical study, 
participants are a subset of
eligible patients who in turn are a subset of 
patients who were assessed.
Because mistakes inevitably arise during manual calculation and transcription,
it is not uncommon for flow diagrams in published studies to contain errors.
And although the errors that make it to publication are often small,
they can occasionally be disastrous.

A solution to the problem of calculating nested subsets
and displaying information about them is presented here.
The idea is to represent nested subsets of a data set
(where the subsets are defined by specific variables in the data set),
using a tree structure, which we call a *variable tree*.

## Basic features of a variable tree

The examples that follow use a data set called `FakeData` which represents `r nrow(FakeData)` fictitious patients.
Based on this data set, the variable tree below depicts subsets defined by `Sex` (M or F)
nested within subsets defined by disease `Severity` (Mild, Moderate, Severe, or NA).
Later we'll see how variable trees with more than two variables are particularly useful.

```{r, echo=FALSE, results="asis"}
cat(vtree(FakeData,"Severity Sex",showlegend=FALSE,horiz=FALSE,
  width=600,height=200,pxwidth=1000,imageheight="2.2in"))
```

A variable tree consists of *nodes* connected by arrows.
At the top of the diagram above, the *root* node of the tree contains all 46 patients.
The rest of the nodes are arranged in successive levels,
where each level corresponds to a variable.
Note that this highlights one difference between variable trees
and some other kinds of trees:
at each level of a variable tree, regardless of the branch,
the nodes represent values of the same variable.
In contrast, consider *decision trees*, which can have
splits on different variables at the same level.
 
Continuing with the variable tree above,
the nodes immediately below the root represent values of `Severity` and
are referred to as the *children* of the root node.
In this case, `Severity` was missing (NA) for 6 patients,
and there is a node for these patients.
Inside each of the nodes, the number of patients is displayed
and---except for in the missing value node---the corresponding percentage is also shown.
Note that, by default, `vtree` displays "valid" percentages,
i.e. the denominator used to calculate the percentage is the total number of non-missing values,
`r sum(!is.na(FakeData$Severity))`.

The nodes in the next level (which is the final level for this tree)
correspond to values of `Sex`.
These nodes represent males and females within subsets defined by each value of `Severity`.
In each of these nodes the percentage is calculated in terms of
the number of patients in its parent node.

Like any node, a missing-value node can have children.
For example, of the 6 patients for whom `Severity` is missing, 3 are female and 3 are male.
By default, `vtree` displays the full missing-value structure of the specified variables in the data frame.

Also by default, `vtree` automatically assigns a color palette to each variable.
`Severity` has been assigned red hues (lightest for Mild, darkest for Severe),
while `Sex` has been assigned blue hues (light blue for females, dark blue for males).
The node representing missing values of `Severity` is colored white to draw attention to it.


## Variable trees vs. contingency tables

A tree with two variables is similar to a two-way contingency table.
In the example above, `Sex` is shown within levels of `Severity`.
This corresponds to the following contingency table,
where the percentages within each column add to 100%.
These are called *column percentages*.

&nbsp;| Mild      | Moderate | Severe   | NA
------|-----------|----------|----------|---------
**F** | 11 (58%)  | 11 (69%) | 2 (40%)  | 3 (50%)
**M** | 8 (42%)   | 5 (31%)  | 3 (60%)  | 3 (50%)

Likewise, a tree with `Severity` shown within levels of `Sex` corresponds to
a contingency table with *row percentages*.

The contingency table above is more compact than the corresponding variable tree,
but some people find the variable tree easier to interpret.
When three of more variables are of interest,
multi-way contingency tables can be used.
These are typically displayed using several two-way tables.
In this situation, variable trees are generally easier to interpret.

It is also noteworthy that contingency tables are not *always* more compact than variable trees.
When most cells of a large contingency table are empty (in which case the table is said to be *sparse*),
the corresponding variable tree may be more compact since empty-nodes are not shown.
 
Variable trees are thus an appealing alternative to multi-way contingency tables
and can also be used to display a wide variety of information including:

* multi-way intersections (often shown in Venn diagrams),

* flow diagrams involving a sequence of inclusion/exclusion steps,

* longitudinal events.


## Features of vtree

`vtree` is designed to be quick and easy to use,
so that it is convenient for data exploration,
but also flexible enough that it can be used to prepare publication-ready figures.
To generate a basic variable tree,
it is only necessary to provide `vtree` with a data frame and some variable names.
However extra features make `vtree` much more useful. 
`vtree` provides:

* control over [labeling](#labeling), colors, [legends](#legends), [line wrapping](#wrapping),
[text formatting](#textFormatting) and other customization features;

* flexible [pruning](#pruning) to remove parts of the tree that are of lesser interest,
which is particularly useful when a tree gets large;

* [display of information about other variables in each node](#summary),
including a variety of summary statistics;

* special displays for [indicator variables](#Venn),
[patterns](#patterns) of values, and
[missing value patterns](#missingValues);

* support for REDCap [checkbox variables](#REDCapCheckboxes); and

* features for [dichotomizing variables](#dichotomizing) and [checking for outliers](#detectingOutliers).

* automatic generation of PNG image files and [embedding in R Markdown](#embeddingPNG) documents.

There is a collection of [examples using R datasets](#RdatasetExamples) later in this vignette.
There is also a [helper function](#GeneratingDataFrames) to easily construct
data frames to use with `vtree`.

## Technical overview

`vtree` is built on open-source software:
in particular Richard Iannone's
[DiagrammeR](http://rich-iannone.github.io/DiagrammeR/) package,
which provides an interface to the
[Graphviz](https://www.graphviz.org/) software using the
[htmlwidgets](https://www.htmlwidgets.org/) framework.
A formal description of variable trees follows.

The root node of the variable tree represents the entire data frame.
The root node has a child for each observed value of the first variable that was specified.
Each of these child nodes represents a subset of the data frame with a specific value of the variable, and is labeled with the number of observations in the subset and the corresponding percentage of the number of observations in the entire data frame.
The *n*^th^ level below the root of the variable tree corresponds to the *n*^th^ variable specified.
Apart from the root node,
each node in the variable tree represents the subset of its parent defined by a specific observed value of the variable at that level of the tree,
and is labeled with the number of observations in that subset and the corresponding percentage of the number of observations in its parent node.

Note that a node always represents at least one observation.
And unlike a contingency table,
which can have empty cells,
a variable tree has no empty nodes.


# The `vtree` function

Consider a data frame named `df`,
which includes discrete variables `v1` and `v2`.
In this case, a variable tree can be displayed using the following command:

```{r, eval=FALSE}
vtree(df,"v1 v2")
```

For additional details about how variables can be specified,
see the section on [specification of variables](#VariableSpecification) below.

Numerous additional parameters can be supplied.
For example, by default `vtree` produces a horizontal tree
(that is, a tree that grows from left to right),
but sometimes a vertical tree is preferable.
When `horiz=FALSE` is specified, `vtree` generates a vertical tree.

Note that if `vtree` is called without a list of variables,
it uses *all* of the variables in the data frame
in the order in which they appear.


## Mini tutorial

To display a variable tree for a single variable, say `Severity`, use the following command:

```{r,eval=FALSE, results="asis"}
vtree(FakeData,"Severity")
```

`r vtree(FakeData,"Severity",width=250,height=250,pxwidth=300,imageheight="2.5in")`

Next, consider a vertical variable tree with two variables, `Severity` and `Sex`.
A less colorful display with more spacing can be requested by specifying `plain=TRUE`:

```{r, eval=FALSE}
vtree(FakeData,"Severity Sex",horiz=FALSE,plain=TRUE)
```

`r vtree(FakeData,"Severity Sex",horiz=FALSE,plain=TRUE,
  width=550,height=200,pxwidth=1600,imageheight="1.9in")`

At the top, the root node represents the entire data frame.
Moving down, each subsequent level of the tree corresponds to a different variable (first `Severity`, then `Sex`).
Within each level, each node represents the subset of its parent node where the variable has a specific value.
For example, the level for `Severity` has nodes Mild, Moderate, Severe, and NA (which represents missing values).
Displayed in each node is the number of observations and
(except in the NA node) the conditional percentage,
i.e. the number of observations in the node expressed as a percentage of the observations in its parent node.

### Percentages

By default, "valid percentages" are shown,
i.e. the denominator is the total number of *non-missing* values.
In the case of `Severity`, there are `r sum(is.na(FakeData$Severity))` missing values,
so the denominator is `r nrow(FakeData)` - `r sum(is.na(FakeData$Severity))` ,
or `r nrow(FakeData) - sum(is.na(FakeData$Severity))`.
There are `r sum(FakeData$Severity %in% "Mild")` Mild cases,
and `r sum(FakeData$Severity %in% "Mild")`/`r nrow(FakeData) - sum(is.na(FakeData$Severity))` =
`r sum(FakeData$Severity %in% "Mild")/(nrow(FakeData) - sum(is.na(FakeData$Severity)))` so the percentage shown is 48%.
No percentage is shown in the NA node since missing values are not included in the denominator.

Alternatively, if you don't want to use valid percentages, specify `vp=FALSE`,
and the denominator will be the total number of observations,
*including* any missing values.
In this case, a percentage is shown in each of the nodes, including any NA nodes.

If you don't wish to see percentages, specify `showpct=FALSE`,
or if you don't need to see counts, specify `showcount=FALSE`.


### Displaying a legend and hiding node labels {#legends}

To include a legend, specify `showlegend=TRUE`.
Next to each level of the tree,
the variable name is displayed together with color discs and the values they correspond to.
For each of the values, overall (*marginal*) counts are shown, together with percentages.

When the legend is shown, the node labels become redundant,
since the colors identify the values of the variables
(although the labels may aid readability).
If you prefer, you can hide the node labels,
by specifying `shownodelabels=FALSE`:

```{r,eval=FALSE}
vtree(FakeData,"Severity Sex",showlegend=TRUE,shownodelabels=FALSE)
```

`r vtree(FakeData,"Severity Sex",showlegend=TRUE,shownodelabels=FALSE,
  width=550,height=450,pxwidth=1200,imageheight="4in",folder=PNGdir)`
  
The legend shows how colors are assigned to the different values of each variable,
and additionally provides marginal (that is, overall) counts and percentages for each variable.
Since `Severity` is the first variable in the tree---i.e., it is not nested within another variable---
the marginal counts and percentages for `Severity` are identical to those displayed in the nodes.
In contrast, for `Sex`, the marginal counts and percentages are different
from what is shown in the nodes because the nodes for `Sex` are nested with levels of `Severity`.

(Unfortunately the NA circle in the legend is oddly sized and positioned due to an issue with the corresponding unicode symbols.)


### Putting node labels on the same line as the counts and percentages

When a variable tree is large,
it can be difficult to display it in a readable way.
One approach that helps is to display the tree horizontally
and also to put the node labels on the same
line as the counts and percentage by specifying `sameline=TRUE`.
For example,
the following results in nodes with single-lines labels such as **Moderate, 16 (40%)**, etc.:

```{r,eval=FALSE}
vtree(FakeData,"Severity Sex Viral",sameline=TRUE)
```



### Hiding variable names

By default, next to each level of the tree, `vtree` shows the variable name.
These can be removed by specifying `showvarnames=FALSE`.


### Text wrapping {#wrapping}

By default,
`vtree` wraps text onto the next line whenever a space occurs after at least 20 characters.
This can be adjusted, for example, to 15 characters,
by specifying `splitwidth=15`.
To disable line splitting, specify `splitwidth=Inf`.
Text wrapping in the legend is controlled independently.
To set the splitting in the legend to 8 characters,
specify `lsplitwidth=8`.
Also note that in the legend,
text wrapping can take place not only at spaces,
but also at any of the following characters: . - + _ = /

### And more ...

This concludes the mini-tutorial.
The rest of this vignette details the many features of `vtree`.
There is also a section of [examples](#RdatasetExamples) using data from the built-in R datasets package.
 
 
## Pruning {#pruning}

*Pruning* a tree means removing specified nodes along with their descendants.
This is useful when a variable tree gets too big,
or when you are only interested in certain parts of the tree.
For convenience, `vtree` provides several different ways to prune a tree,
described below.

### The `prune` parameter

Suppose you don't want the tree to include individuals whose disease is Mild or Moderate.
You can use the `prune` parameter to remove those nodes,
and all of their descendants.

The `prune` parameter is specified as a list with an element named for each variable you wish to prune.
In the example below the list has one element, named `Severity`.
That element in turn is a vector `c("Mild","Moderate")` indicating the values to prune.

```{r,eval=FALSE}
vtree(FakeData,"Severity Sex",prune=list(Severity=c("Mild","Moderate")))
```

`r vtree(FakeData,"Severity Sex",prune=list(Severity=c("Mild","Moderate")),
  width=500,height=300,pxwidth=600,imageheight="2.5in",folder=PNGdir)`


**Caution**: Once a variable tree has been pruned,
it is no longer complete.
This can sometimes be confusing since not all observations
are present at some levels of the tree.
**It is particularly important to avoid pruning missing value nodes**,
since this makes it hard to interpret "valid" percentages (i.e. percentages calculated
using the number of non-missing observations as denominator).


### The `prunebelow` parameter

A disadvantage of the `prune` parameter is that in the resulting tree,
the counts shown in child nodes may not add up to the counts shown in the parent node.
For example in the variable tree above,
of a total of 46 patients,
5 have Severe disease and `Severity` is unknown for 6.
One might wonder what happened to the other 35 patients.

An alternative is to prune *below* the specified nodes.
In this case, this means that the Mild and Moderate nodes will be shown,
but not their descendants.

```{r,eval=FALSE}
vtree(FakeData,"Severity Sex",prunebelow=list(Severity=c("Mild","Moderate")))
```

`r vtree(FakeData,"Severity Sex",prunebelow=list(Severity=c("Mild","Moderate")),
  width=500,height=300,pxwidth=600,imageheight="3in",folder=PNGdir)`


### The `keep` and `follow` parameters

Instead of specifying the nodes that should be discarded,
sometimes it is more convenient to specify the nodes that should be *retained*.
The `keep` parameter is used to specify nodes that should *not* be pruned
(all other nodes at that level of the tree will be pruned).
The `follow` parameter is like the `keep` parameter except that no nodes at that level of the tree will be pruned.
Instead, those nodes that are not "followed" will be pruned at the next level.

### The `prunesmaller` parameter

When the number of nodes in a variable tree gets very large,
it may be hard to see where most of the observations actually are.
One solution is to prune nodes that contain small numbers of observations.
For example if you want to only see nodes with at least 3 observations,
you can specify `prunesmaller=3` as in this example:

```{r, eval=FALSE}
vtree(FakeData,"Severity Sex Age Category",sameline=TRUE,prunesmaller=3)
```


## Changing how variables and nodes are labeled {#labeling}

By default, `vtree` labels variables and nodes exactly as they are in the data frame.
For presentation purposes it is often useful to change these labels.

### Changing variable labels with the `labelvar` parameter

If `Severity` in fact represents severity on day 1,
you might want it to appear that way in the variable tree.
To do this, use the `labelvar` parameter,
which is specified as a vector whose element names are variable names.
As an example, if `Severity` in fact represents initial severity,
you can specify `labelvar=c(Severity="Initial severity")`.

```{r,eval=FALSE}
vtree(FakeData,"Severity Sex",horiz=FALSE,labelvar=c(Severity="Initial severity"))
```

`r vtree(FakeData,"Severity Sex",horiz=FALSE,
  labelvar=c(Severity="Initial severity"),
  width=700,height=250,pxwidth=1200,imageheight="2.2in",folder=PNGdir)`
  
  
### Changing node labels with the `labelnode` parameter

By default, `vtree` labels nodes (except for the root node)
using the values of the variable in question.
(If the variable is a factor, the levels of the factor are used).
Sometimes it is convenient to instead specify custom labels for nodes.
You can use the `labelnode` argument to relabel the values.
For example, you might want to use "Male" and "Female" instead of "M" and "F".
The `labelnode` argument argument is specified as a list whose element names are variable names.
To substitute `New label` for `Old label`,
the syntax is: `"New label"="Old label"`.
Thus the full specification is: `labelnode=list(Sex=c(Male="M",Female="F"))`.

```{r,eval=FALSE}
vtree(FakeData,"Group Sex",horiz=FALSE,labelnode=list(Sex=c(Male="M",Female="F")))
```

`r vtree(FakeData,"Group Sex",horiz=FALSE,labelnode=list(Sex=c(Male="M",Female="F")),
  width=700,height=250,pxwidth=800,imageheight="2.2in",folder=PNGdir)`


### Targeted node labels using the `tlabelnode` parameter

Suppose in the example above that `Group` A represents children and
`Group` B represents adults.
In `Group` A, we would like to use the labels "girl" and "boy",
while in `Group` B we would like to use "woman" and "man".
The `labelnode` parameter cannot handle this situation because the values of
`Sex` need to labeled differently in different branches of the tree.
The `tlabelnode` parameter allows "targeted" node labels.

```{r,eval=FALSE}
vtree(FakeData,"Group Sex",horiz=FALSE,
  labelnode=list(Group=c(Child="A",Adult="B")),
  tlabelnode=list(
    c(Group="A",Sex="F",label="girl"),
    c(Group="A",Sex="M",label="boy"),
    c(Group="B",Sex="F",label="woman"),
    c(Group="B",Sex="M",label="man")))
```

`r vtree(FakeData,"Group Sex",horiz=FALSE,
  labelnode=list(Group=c(Child="A",Adult="B")),
  tlabelnode=list(
    c(Group="A",Sex="F",label="girl"),
    c(Group="A",Sex="M",label="boy"),
    c(Group="B",Sex="F",label="woman"),
    c(Group="B",Sex="M",label="man")),
  width=700,height=250,pxwidth=1000,imageheight="2.2in",folder=PNGdir)`


## Text and text formatting {#textFormatting}

`Graphviz`,
the open source graph visualization software that provides the basis for `vtree`,
supports a variety of text formatting (including boldface, colors, etc.).
This is used in `vtree` to control formatting of text such as node labels.

### HTML-like codes for text formatting

**NOTE: The section after this one shows how to use an easy alternative to HTML-like codes.**

`Graphviz` implements "HTML-like labels", including:

* `<BR/>` means insert a line break
* `<BR ALIGN='LEFT'/>` means make the preceding line left-justified and insert a line break
* `<I> ... </I>` means display text in italics
* `<B> ... </B>` means display text in bold
* `<SUP> ... </SUP>` means display text in superscript,
  but note that the font size does not change
* `<SUB> ... </SUB>` means display text in subscript
  but again note that the font size does not change
* `<FONT POINT-SIZE='10'> ... </FONT>` means set font to 10 point
* `<FONT FACE='Times-Roman'> ... </FONT>` means set font to Times-Roman
* `<FONT COLOR='red'> ... </FONT>` means set font to red

See <https://www.graphviz.org/doc/info/shapes.html#html> for more details.

**Note**: To use these HTML-like codes, it is necessary to specify `HTMLtext=TRUE`.


### Markdown-style codes for text formatting

By default, the `vtree` package uses markdown-style codes for text formatting.

* `\n` means insert a line break
* `\n*l` means make the preceding line left-justified and insert a line break
* `*...*` means display text in italics
* `**...**` means display text in bold
* `^...^` means display text in superscript (using 10 point font)
* `~...~` means display text in subscript (using 10 point font)
* `%%red ...%%` means display text in red (or whichever color is specified)


### Adding text to nodes using the `text` parameter

Suppose you wish to add the italicized text "*Excluding new diagnoses*"
to any Mild nodes in the tree.
The parameter `text` lets you add text to nodes.
It is specified as a list with an element named for each variable.
In the example below the list has one element, named `Severity`.
That element in turn is a vector `c(Mild="\n*Excluding\nnew diagnoses*")`
indicating that the Mild node should include additional text using Markdown-style formatting
(i.e. there is a linebreak and the asterisks around the text indicate that it should be displayed in italics):

```{r,eval=FALSE}
vtree(FakeData,"Group Severity",horiz=FALSE,showvarnames=FALSE,
  text=list(Severity=c(Mild="\n*Excluding\nnew diagnoses*")))
```

`r vtree(FakeData,"Group Severity",horiz=FALSE,showvarnames=FALSE,
  text=list(Severity=c(Mild="\n*Excluding\nnew diagnoses*")),
  width=450,height=150,pxwidth=1200,imageheight="2.5in",folder=PNGdir)`
  

### Targeted text using the `ttext` parameter

In the example above,
suppose that new diagnoses are only excluded from Mild cases in `Group` B.
But the `text` parameter is used to add text to *all* Mild nodes.
Thus, in situations like this, the `text` parameter is not sufficient.
Instead, you can use the `ttext` parameter to target
exactly which nodes should have the specified text.

The `ttext` parameter requires that you specify the full path from the root of the tree to the node in question,
along with the text in question.
The `ttext` parameter is specified as a list so that multiple targeted text strings can be specified at once.
For example:

```{r,eval=FALSE}
vtree(FakeData,"Group Severity",horiz=FALSE,showvarnames=FALSE,
  ttext=list(
    c(Group="B",Severity="Mild",text="\n*Excluding\nnew diagnoses*"),
    c(Group="A",text="\nSweden"),
    c(Group="B",text="\nNorway")))
```

`r vtree(FakeData,"Group Severity",horiz=FALSE,showvarnames=FALSE,
  ttext=list(c(Group="B",Severity="Mild",text="\n*Excluding\nnew diagnoses*"),
    c(Group="A",text="\nSweden"),c(Group="B",text="\nNorway")),
  width=450,height=150,pxwidth=1000,imageheight="2.5in",folder=PNGdir)`
  

## Specification of variables {#VariableSpecification}
 
For convenience,
vtree allows you to specify the variable names in a single character string
(with the variable names separated by whitespace).
If, however, any of the variable names have internal spaces,
the variable names must be specified as a vector of character strings.
 
Additionally, there are several modifiers that can be used
to change the way that variables are represented in a tree.
 
 
### prefix `is.na:`

If an individual variable name is preceded by `is.na:`,
that variable will be replaced by a missing value indicator in the variable tree.
(This differs from the `check.is.na` parameter, described below,
which is used to replace *all* of the specified variables with missing value indicators.)


### prefix `stem:`

In datasets exported from [REDCap](https://www.project-redcap.org/),
checkboxes are represented using multiple variables.
The `stem:` prefix makes it easier to work with them.
This is described in the section on [REDCap checkboxes](#REDCapCheckboxes)
later in this vignette.


### prefix `tri:` {#detectingOutliers}

The `tri:` prefix is useful for identifying values of a numeric variable
that are *extreme* compared to the other values in a node.
**Note:** Unlike other variable specifications,
which take effect at the level of the entire data frame,
the `tri:` prefix takes effect within each node.

The effect of this variable specification
is to trichotomize a numeric variable within a node
based on the median and the IQR, both computed within that node.
The result is three categories:

* "mid": namely values within plus or minus 1.5&times;IQR of the median,

* "high": namely values more than 1.5&times;IQR above the median,

* "low": namely values more than 1.5&times;IQR below the median.


### suffix `*`

In `FakeData`,
specifying `Ind*` matches all variable names that start with `Ind`,
namely `Ind1`, `Ind2`, and `Ind3`.

The `*` suffix matches all variable names


### suffix `#`

Specifying `Ind#` matches all variable names that start with `Ind`
and end with a numeric digit, namely `Ind1`, `Ind2`, and `Ind3`.
(In this case this is the same result as using `Ind*`).


### specification `variable=value` {#dichotomizing}

When a variable takes on a large number of different values,
it will result in a very large variable tree.
One solution is to prune the tree,
for example by keeping just one node.
An alternative is to specify the value of the variable that is of primary interest.
The result will be to dichotomize the variable at that value.
For example if `Severity=Mild` is specified,
the `Severity` variable will be dichotomized between `Mild` and `Not Mild`.


### specifications `variable<value`, `variable>value`

These two specifications are used to dichotomize a *numeric* variable,
splitting above and below a specified value.
This can be useful for identifying subsets with extreme values.


## Displaying summary statistics in nodes {#summary}

It is often useful to display information about other variables
(apart from those that define the tree) in the nodes of a variable tree.
This is particularly useful for numeric variables,
which generally cannot be used to build the tree since they have too many distinct values.
For example, we might wish to display the mean age for individuals in each node.
Or we might wish to list the ID numbers for individuals in each node.
The `summary` argument can be used to flexibly specify additional information to display.


### A simple example

The argument of the `summary` parameter is a character string with the following structure:

* It starts with the name of the variable for which a summary is desired. (We'll see later that variable specifications and expressions can also be used, as long as they do not contain any spaces.)

* Next there is a space.

* The remainder of the string specifies what to display, with special codes to indicate the type of summary desired to control which nodes display the summary, etc.

For example `%mean%` indicates that the mean of the specified variable should be shown.
Thus to display the mean of the numeric variable `Score`,
you could specify `summary="Score \nmean score: %mean%"`.
Note that the part of the string following the first space is
`"\nmean score: %mean%"`.
This specifies that in each node, after the usual frequency and percentage,
the summary should start on a new line with the words "mean score: " followed by the mean.

```{r,eval=FALSE}
vtree(FakeData,"Severity",summary="Score \nmean score: %mean%",sameline=TRUE,horiz=FALSE)
```

`r vtree(FakeData,"Severity",summary="Score \nmean score: %mean%",
  sameline=TRUE,horiz=FALSE,
  width=450,height=150,pxwidth=1000,imageheight="1.6in",folder=PNGdir)`
  

To see the means without any decimals, the `cdigits` parameter can be used;
for example:

```{r,eval=FALSE}
vtree(FakeData,"Severity",summary="Score \nmean score: %mean%",cdigits=0,
  sameline=TRUE,horiz=FALSE)
```


The following codes can be used to show summary information:

code            | result
:---------------|:-------------------------------------------------------------------
`%mean%`        |  mean
`%SD%`          |  standard deviation
`%sum%`         |  sum
`%min%`         |  minimum
`%max%`         |  maximum
`%pX%`          |  Xth percentile (e.g. `p50` means the 50th percentile)
`%median%`      |  median, i.e. p50
`%IQR%`         |  IQR, i.e. p25, p75
`%npct%`        |  frequency and percentage of a logical variable. By default "valid percentages" are used. Any missing values are also reported.     
`%pct%`         |  same as `%npct%` but percentage only (with no parentheses).
`%list%`        |  list of individual values, separated by commas
`%listlines%`   |  list of individual values, each on a separate line
`%mv%`          |  the number of missing values
`%v%`           |  the name of the variable

The `summary` argument can use any number of these codes,
mixed with text and formatting codes.


### More than one variable

Sometimes it is useful to display summary information for more than one variable.
To do this, specify `summary` as a vector of character strings:

```{r,eval=FALSE}
vtree(FakeData,"Severity",horiz=FALSE,showvarnames=FALSE,splitwidth=Inf,sameline=TRUE,
  summary=c("Score \nScore: mean (SD) %mean% (%SD%)","Pre \nPre: range %min%, %max%"))
```

`r vtree(FakeData,"Severity",horiz=FALSE,showvarnames=FALSE,splitwidth=Inf,sameline=TRUE,
  summary=c(
    "Score \nScore: mean (SD) %mean% (%SD%)",
    "Pre \nPre: range %min%, %max%"),
  width=650,height=350,pxwidth=1000,imageheight="1.5in",folder=PNGdir)`
  

### The %list% code

It is sometimes convenient to see individual values of a variable in each node.
For example it is often convenient to see ID numbers.
To do this, use the `%list%` code.
By default this information will be displayed in each node.
When a value occurs more than once in the subset,
it will be followed by a count of the number of repetitions in parentheses.
The `%list%` code separates values by commas.
Alternatively, the `%listlines%` code can be used to put each value on a new line.

When there are many IDs, it is often convenient to truncate the output.
The `%trunc=`*N*`%` code specifies that, after *N* characters, summary information
should be truncated with "...".


### The `%noroot%`, `%leafonly%`, `%var=`*v*`%`, and `%node=`*n*`%` codes

By default, summary information is shown in all nodes.
However, it may also be convenient to only show it in specific nodes.
The following codes are available:

**code**         | **summary information restricted to:**
-----------------|----------------------------------------
`%noroot%`       | all nodes *except* the root
`%leafonly%`     | leaf nodes
`%var=`*v*`%`    | nodes of variable *v*
`%node=`*n*`%`   | nodes named *n*


### Specification of variables in the summary argument

Variables in the `summary` parameter can also be specified in a way similar
to the [specification of variables](#VariableSpecification) for structuring a variable tree.
For example, if we wish to know the proportion of patients in each node whose `Category` is single,
we specify `Category=single` in the `summary` argument.

```{r,eval=FALSE}
vtree(FakeData,"Severity",summary="Category=single \n%pct% single",sameline=TRUE,horiz=FALSE)
```

`r vtree(FakeData,"Severity",summary="Category=single \n%pct% single", 
  horiz=FALSE,sameline=TRUE,
  width=450,height=150,pxwidth=800,imageheight="1.3in",folder=PNGdir)`
  

Continuous variables such as `Score` can be dichotomized using
notation such as `Score>10` or `Score<20`.


### R expressions in the summary argument

Rather than starting the `summary` argument with a variable name,
an R expression involving variables in the data frame can be given,
as long as it does not contain any spaces.

```{r,eval=FALSE}
vtree(FakeData,"Severity Category",
  summary="(Post-Pre)/Pre \nmean = %mean%",sameline=TRUE,horiz=FALSE,cdigits=1)
```

`r vtree(FakeData,"Severity Category",
  summary="(Post-Pre)/Pre \nmean = %mean%",sameline=TRUE,horiz=FALSE,cdigits=1,
  width=450,height=150,pxwidth=1000,imageheight="2in",folder=PNGdir)`

Expressions involving functions can also be used; for example `sqrt(abs(Post/Pre))`.


### Showing/hiding summaries on a node-by-node basis depending on the data in the node using the `runsummary` parameter

Sometimes it is desirable to show summaries only in nodes with certain characteristics.
Consider the following example:
suppose that in patients with a viral infection,
the presence or absence of two features of the virus
(Feature 1 and Feature 2) is recorded.
To simulate this situation,
let's make up variables `Feature1` and `Feature2` but set them to NA if the `Viral` variable is FALSE or NA.

```{r}
set.seed(1234)
FakeData$Feature1 <- rbinom(nrow(FakeData),1,0.5)
FakeData$Feature1[!FakeData$Viral | is.na(FakeData$Viral)] <- NA
FakeData$Feature2 <- rbinom(nrow(FakeData),1,0.5)
FakeData$Feature2[!FakeData$Viral | is.na(FakeData$Viral)] <- NA
```

Here is a tree for `Sex` and `Category` showing three summaries in each leaf node:
the number and percent of patients with viral infections
and number and percent of viruses with Feature 1 and with Feature 2.

```{r,eval=FALSE,results="asis"}
vtree(FakeData,"Sex Category",sameline=TRUE,splitwidth=150,varminwidth=c(Category=6),
  summary=c(
    "Viral \nviral: %npct%%leafonly%",
    "Feature1 , F1: %npct%%leafonly%",
    "Feature2 , F2: %npct%%leafonly%"))
```

`r vtree(FakeData,"Sex Category",sameline=TRUE,splitwidth=150,varminwidth=c(Category=6),
  summary=c(
    "Viral \nviral: %npct%%leafonly%",
    "Feature1 , F1: %npct%%leafonly%",
    "Feature2 , F2: %npct%%leafonly%"),
  pxwidth=800,imageheight="3in",folder=PNGdir)`

But note that in two of the nodes there are no viral infections,
so in these nodes there are no virus features to describe.
The tree would be improved if we could turn off the summaries in nodes where there are no viral infections.
We can do this by specifying, for each of the three summaries,
a function that returns TRUE or FALSE for each node.
The first function always returns TRUE:

```{r, eval=FALSE}
function(x) TRUE
```

The next two functions return TRUE if there is at least one viral infection in the node:

```{r, eval=FALSE}
function(x) any(x$Viral,na.rm=TRUE)
```

These three functions are specified (in a list) using the `runsummary` parameter:

```{r,eval=FALSE}
vtree(FakeData,"Sex Category",sameline=TRUE,splitwidth=150,varminwidth=c(Category=6),
  summary=c(
    "Viral \nviral: %npct%%leafonly%",
    "Feature1 , F1: %npct%%leafonly%",
    "Feature2 , F2: %npct%%leafonly%"),
  runsummary=list(
    function(x) TRUE,
    function(x) any(x$Viral,na.rm=TRUE),
    function(x) any(x$Viral,na.rm=TRUE)))
```

`r vtree(FakeData,"Sex Category",sameline=TRUE,splitwidth=150,varminwidth=c(Category=6),
  width=950,height=900,
  summary=c(
    "Viral \nviral: %npct%%leafonly%",
    "Feature1 , F1: %npct%%leafonly%",
    "Feature2 , F2: %npct%%leafonly%"),
  runsummary=list(
    function(x) TRUE,
    function(x) any(x$Viral,na.rm=TRUE),
    function(x) any(x$Viral,na.rm=TRUE)),
  pxwidth=800,imageheight="3in",folder=PNGdir)`
  

## Pattern trees {#patterns}

Each leaf node in a tree provides the frequency of a particular pattern (combination)
of values of the variables.
For example, in a variable tree for `Severity` and `Sex`,
the leaf nodes correspond to Mild F, Mild M, Moderate F, Moderate M, etc.
If these patterns themselves are used as the first variable in a tree,
then the tree will be "detangled";
that is, each branch of the tree will represent a unique pattern.
A "pattern tree" can be easily produced by specifying `pattern=TRUE`:

```{r, eval=FALSE}
vtree(FakeData,"Severity Sex")
vtree(FakeData,"Severity Sex",pattern=TRUE)
```
```{r, echo=FALSE,results="asis"}
cat(vtree(FakeData,"Severity Sex",
  width=650,height=650,pxwidth=600,imageheight="4in",folder=PNGdir))
#filepath <- grVizToPNG(v14,folder=PNGdir,width=800))

cat("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")

cat(vtree(FakeData,"Severity Sex",pattern=TRUE,
  width=650,height=650,pxwidth=600,imageheight="4in",folder=PNGdir))
#filepath2 <- grVizToPNG(v15,folder=PNGdir,width=800)
#![](`r filepath`){ height=4in } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ![](`r filepath2`){ height=4in }
```



Pattern trees are easier to read,
but they involve a considerable a loss of information,
since they only represent the *n*th-level subsets
(where *n* is the number of variables)..

Note that, by default, the root node is not shown when `pattern=TRUE` is specified,
because this simplifies the display
(in fact, without the root node, it is no longer a tree!).
A disadvantage of this is that the total sample size is not shown.
The root node can be shown by specifying `showroot=TRUE`.

This tree has two other special characteristics.
First, note that after the first level (representing `pattern`),
counts and percentages are not shown,
since they are not informative:
by definition, all nodes within a branch have the same count.
Second, note that in place of arrows, undirected line segments are shown.
This is because, without percentages, arrows have no particular significance.
That being said, in some cases there is a natural ordering to the variables
(as is the case with longitudinal variables).
To show arrows, specify `seq=TRUE` instead of `pattern=TRUE`,
and a "sequence" (i.e. an ordered pattern) will be shown.

Summaries can be shown in pattern trees
(using the `summary` parameter), but they only appear in the pattern node
(or the sequence node if `seq=TRUE`).


### Pattern tables

When `pattern=TRUE` is specified, the variable tree looks a lot like a table.
In fact a data frame containing the information from the pattern tree 
can be exported by specifying `ptable=TRUE`:

```{r}
vtree(FakeData,"Severity Sex",ptable=TRUE)
```

This compact representation may be convenient for display in a manuscript.

When a pattern table is created for indicator variables,
it provides all the information of a Venn Diagram.
For example:

```{r}
vtree(FakeData,"Ind1 Ind2",ptable=TRUE)
```

For indicator variables, there is an extra function, `VennTable`,
which converts the pattern table to a matrix of character strings,
adds some additional totals, and does some formatting:

```{r}
print(VennTable(vtree(FakeData,"Ind1 Ind2",ptable=TRUE)),quote=FALSE)
```

(In the example above, quotation marks are suppressed.
This is done because ordinarily a matrix of character strings is shown with
quotation marks, which are a bit distracting.)

Summaries can be very useful in pattern tables.
If a single summary is requested, it appears in the `summary_1` variable in the data frame.
If additional summaries are requested they appear as `summary_2`, `summary_3`, etc.

```{r}
vtree(FakeData,"Severity Sex",summary=c("Score %mean%","Pre %mean%"),ptable=TRUE)
```



## Special variable trees

### Multi-way intersections {#Venn}

A Venn diagram is used to show all intersections between several sets.
When there are more than three sets, Venn diagrams are hard to construct and to read.
Additionally, Venn diagrams cannot represent missing values.

One alternative is to use variable trees.
In the following example,
the variables `Ind1` through `Ind4` are indicators of set membership
(0 = not a member of the set, 1 = member).
Convenient settings for such variables are requested by specifying `Venn=TRUE`:

```{r, eval=FALSE}
vtree(FakeData,"Ind1 Ind2 Ind3 Ind4",Venn=TRUE)
```

`r vtree(FakeData,"Ind1 Ind2 Ind3 Ind4",Venn=TRUE,
  width=650,height=650,pxwidth=800,imageheight="6in",folder=PNGdir)`

Note that for simplicity, node labels are not shown.
Instead, dark colors indicate set membership,
while light colors indicate non-membership.
Also, percentages are not shown by default.
Specifying `showpct=TRUE` displays percentages.

In contrast to a Venn diagram, which shows all intersections,
a variable tree only shows information on specific intersections,
determined by the ordering of the variables.
 
Specifying `pattern=TRUE` produces an even simpler representation,
since only the full *n*-way intersections (where *n* is the number of variables)
are represented:


```{r,eval=FALSE}
vtree(FakeData,"Ind1 Ind2 Ind3 Ind4",Venn=TRUE,pattern=TRUE,
  palette=c(Ind1=1,Ind2=2,Ind3=3,Ind4=4))
```

`r vtree(FakeData,"Ind1 Ind2 Ind3 Ind4",Venn=TRUE,pattern=TRUE,
  palette=c(Ind1=1,Ind2=2,Ind3=3,Ind4=4),
  pxwidth=600,imageheight="4.5in",folder=PNGdir)`
  

Note that in the call to `vtree` above,
the `palette` parameter is specified so that the color palettes match
with the preceding variable tree.
(Otherwise, `pattern` gets palette number 1,
and then `Ind1` gets  palette number 2, and so on.)

Although this tree provides less information than the branching-style tree,
it is more easily interpreted.
This kind of tree is also useful for investigating incomplete longitudinal data.


### Checking for missing values with the `check.is.na` parameter {#missingValues}

The `check.is.na` parameter is used to produce a tree that only shows whether
the specified variables are missing or not.
By default, `pattern=TRUE` is also set when `check.is.na=TRUE`.
Whereas the variables that `vtree` uses to build variable trees are usually categorical,
this is a situation where non-categorical variables can be used,
because their missingness is represented instead of their actual values.

```{r,eval=FALSE}
vtree(FakeData,"Severity Age Pre Post",check.is.na=TRUE)
```

`r vtree(FakeData,"Severity Age Pre Post",check.is.na=TRUE,
  width=700,height=370,pxwidth=600,imageheight="3in",folder=PNGdir)`

Specifying `ptable=TRUE` produces this information in a data frame:

```{r}
vtree(FakeData,"Severity Age Pre Post",check.is.na=TRUE,ptable=TRUE)
```

Note that the columns `n` and `pct` represent the frequency and percentage of the total number of cases.

It may be useful to identify the ids for these patterns. Here the results are truncated to 15 characters:

```{r}
vtree(FakeData,"Severity Age Pre Post",check.is.na=TRUE,summary="id %list%%trunc=15%",
  ptable=TRUE)
```


### Rudimentary CONSORT diagrams

Consider the following fictitious data about a randomized controlled trial (RCT):

```{r}
FakeRCT
```

The CONSORT diagram (http://www.consort-statement.org/) shows the flow of patients through the study starting with
those who meet eligibility criteria, then those who are randomized to each group, etc.
It is easy to produce a rudimentary version of a CONSORT diagram in `vtree`.
The key step is to prune branches for those who are *not* eligible, *not* randomized, etc.
This can be done using the `keep` parameter:

```{r,eval=FALSE}
vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  keep=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility")
```

`r vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  keep=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility",
  width=230,height=500,pxwidth=500,imageheight="6in",folder=PNGdir)`
  

Note that this does not include all of the additional information for a full CONSORT diagram
(exclusion reasons and counts,
as well as numbers of patients who received their allocated interventions,
who discontinued intervention, and who were excluded from analysis).
It does, however, provide the main flow information.

Additional information can be obtained by examining the nodes for patients in the pruned branches.
The `follow` parameter allows that:

```{r,eval=FALSE}
vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  follow=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility")
```

`r vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  follow=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility",
  width=400,height=500,pxwidth=800,imageheight="6in",folder=PNGdir)`

Finally, it may be useful to see the identification numbers in each node.
This can be done using the `summary` parameter with the `%list%` code.
Since IDs are not as useful in the root note, the `%noroot%` code is also specified here:

```{r, eval=FALSE}
vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  follow=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility",
  summary="id \nid: %list% %noroot%")
```

`r vtree(FakeRCT,"eligible randomized group followup analyzed",plain=TRUE,
  follow=list(eligible="Eligible",randomized="Randomized",followup="Followed up"),
  horiz=FALSE,showvarnames=FALSE,title="Assessed for eligibility",
  summary="id \nid: %list% %noroot%",
  width=500,height=600,pxwidth=700,imageheight="6in",folder=PNGdir)`

## REDCap checkboxes {#REDCapCheckboxes}

In datasets exported from [REDCap](https://www.project-redcap.org/),
checkboxes (i.e. the boxes where you select all that apply)
are represented in a special way.
For each item in a checklist, a separate variable is created.
Suppose survey respondents were asked to select which flavors of ice cream (Chocolate, Vanilla, Strawberry) they like.
Within REDCap,
the variable name for this list of checkboxes is `IceCream`,
but when the dataset is exported,
individual variables `IceCream___1` (representing Chocolate), 
`IceCream___2` (Vanilla), and `IceCream___3` (Strawberry) are created.
When the dataset is read into R,
the names of the flavours are embedded in the `attributes` of these variables.

`vtree` includes a feature designed to make REDCap checkbox variables easier to use.
Instead of typing:

```{r eval=FALSE}
vtree(MyREDCapData,"IceCream___1 IceCream___2 IceCream___3")
```

you can use a special syntax where `stem:` precedes the REDCap variable name:

```{r eval=FALSE}
vtree(MyREDCapData,"stem:IceCream")
```

By default,
`vtree` will also extract the names of the choices and create variables with those names.
(This can be disabled by specifying `choicechecklist=FALSE`.)

An especially convenient way to display checkbox variables with `vtree` is:

```{r eval=FALSE}
vtree(MyREDCapData,"stem:IceCream",pattern=TRUE,showroot=FALSE)
```


## Additional Graphviz customization

`vtree` has three additional parameters to access GraphViz attributes: `graphattr` (for graph attributes), `nodeattr` (node attributes), and `edgeatttr` (edge attributes).
A full list of Graphviz attributes is [available](https://www.graphviz.org/doc/info/attrs.html).

For example, two edge attributes are `arrowhead`,
which specifies the type of arrow,
and `penwidth`, which specifies the thickness of the edge (in points).
(Note that `penwidth` is also a node attribute.)
To draw a variable tree without any arrows on the edges and with thick edges, use:
```{r,eval=FALSE}
vtree(FakeData,"Severity",edgeattr="arrowhead=none penwidth=4",sameline=TRUE)
```
 
The minimum width of nodes (in inches) can be specified using the node attribute `width`:
```{r,eval=FALSE}
vtree(FakeData,"Severity",nodeattr="width=2",sameline=TRUE)
```
 


## Examining the DOT script generated by `vtree`

Specifying `getscript=TRUE` lets you capture the DOT script representing a flowchart.
Here is an example:

```{r, comment=""}
dotscript <- vtree(FakeData,"Severity",getscript=TRUE)
cat(dotscript)
```

If you wish to directly edit this code,
it can can be pasted into one of these online Graphviz editors:

https://dreampuf.github.io/GraphvizOnline

http://magjac.com/graphviz-visual-editor/


# Different ways to call vtree

`vtree` behaves differently depending on how it is called.

## Calling vtree interactively 

* If `vtree` is called interactively in RStudio, it displays the variable tree in the Viewer window.

* If `vtree` is called interactively from the R console, it displays the variable tree in a browser window.

## Calling vtree from R Markdown {#embeddingPNG}

If `vtree` is called while an R Markdown file is being knitted, it generates a PNG file and automatically embeds it into the knitted document.
The resolution of the PNG file is determined by parameters `pxwidth` and `pxheight`.
If neither is specified, `pxwidth` is automatically set to 2000.
The height of the image in the R Markdown output document can be specified 
using the `imageheight` parameter,
for example `imageheight="4in"` for a 4-inch image.
There is also an `imagewidth` parameter.
If neither is specified, `imageheight` is automatically set to 3 inches.

### htmlwidgets

When knitting to an HTML document, 
an htmlwidget can used rather than embedding a PNG file.
(In fact the PNG files are generated from SVG files obtained from htmlwidgets.)
To use an htmlwidget instead of a PNG file, you can use inline code:

```{r, eval=FALSE}
`r vtree(FakeData,"Severity Sex",pngknit=FALSE)`
```

Or a code chunk:

````
`r ''````{r}
vtree(FakeData,"Severity Sex",pngknit=FALSE)
```
````

However when multiple htmlwidgets are included in an HTML file,
browsers may not perform well.
Furthermore, when knitting to a .docx file rather than an HTML file,
htmlwidgets are not an option.

### PNG files

The PNG file is stored in the folder specified by the `folder` parameter,
or if a folder is not specified, a temporary folder will be used.
Successive PNG files are named `vtree1.png`, `vtree2.png`, and so forth and are stored in the  folder.
During knitting, `vtree` uses a global counting variable called `vtcount` to count the PNG files,
and a global folder called `vtfolder` to identify where to store them.

To call `vtree` in R Markdown, you can use inline code:

```{r, eval=FALSE}
`r vtree(FakeData,"Sex Severity")`
```

Or you can use a code chunk:

````
`r ''````{r, results="asis"}
cat(vtree(FakeData,"Sex Severity"))
```
````

One advantage of code chunks is that they can also be run interactively
(for example within RStudio, by clicking of the green arrow at the right-hand side of a code chunk).


# Generating a data frame by specifying subset sizes {#GeneratingDataFrames}

`vtree` is designed to generate a variable tree based on a data frame.
However, sometimes no data frame is available, but the sizes of subsets are known.

The `build.data.frame` function allows you to build a data frame by specifying the size of subsets.
Here's an example involving pets:

```{r}
build.data.frame(
  c("pet","color","spots"),
  list("fish","green","red",2),
  list("dog","black","no",1))
```

In this case there are two green fish with red spots and one black dog.
Although a data frame like this could easily be created without using `build.data.frame`,
it's a different situation when the counts are large.
For example:

```{r, eval=FALSE}
vtree(build.data.frame(
  c("pet","color","spots"),
  list("fish","green","red",2),
  list("dog","black","no",1),  
  list("dog","white","black",101),
  list("dog","white","no",3),
  list("dog","brown","no",5),
  list("dog","black","no",22),
  list("cat","black","no",31),
  list("fish","green","white",16),
  list("fish","green","red",2)))
```

```{r, echo=FALSE}
df <- NULL
df <- build.data.frame(
  c("pet","color","spots"),
  list("fish","green","red",2),
  list("dog","black","no",1),  
  list("dog","white","black",101),
  list("dog","white","no",3),
  list("dog","brown","no",5),
  list("dog","black","no",22),
  list("cat","black","no",31),
  list("fish","green","white",16),
  list("fish","green","red",2))
```

`r vtree(df,imagewidth="4in",pxwidth=800)`

# Examples using R datasets {#RdatasetExamples}

The R datasets package is loaded in R by default.
In what follows, `vtree` is applied to some of these data sets for illustrative purposes.
Note that the variable trees generated by the commands below are not shown.
The reader can try these commands to see what the variable trees look like,
and experiment with many other possibilities.


## Esophageal cancer

The `esoph` data set
(data from a case-control study of esophageal cancer in Ille-et-Vilaine, France), 
has 88 different combinations of age group, alcohol consumption, and tobacco consumption.
Let's examine the total number of cases and the total number of controls
among patients aged 75 and older compared to the rest of the patients:

```{r, eval=FALSE}
vtree(esoph,"agegp=75+",sameline=TRUE,cdigits=0,
  summary=c("ncases \ncases=%sum%%leafonly%","ncontrols  controls=%sum%%leafonly%"))
```


## Hair and eye color

The `HairEyeColor` data set is an array representing a contingency table
(also called a crosstab or crosstabulation).
Before `vtree` can be applied to this data set,
it is necessary to convert the table of crosstabulated frequencies to a data frame of cases.
For convenience, the `vtree` package includes a helper function to do this,
called `crosstabToCases`.
It is adapted from a function listed on the [Cookbook for R website](http://www.cookbook-r.com/Manipulating_data/Converting_between_data_frames_and_contingency_tables/#countstocases-function)

```{r, eval=FALSE}
hec <- crosstabToCases(HairEyeColor)
```

There are a lot of combinations but let's say we are especially interested
in green eyes (as compared to non-green eyes).
We can use the variable specification `Eye=Green` to do this: 
```{r, eval=FALSE}
vtree(hec,"Hair Eye=Green Sex",sameline=TRUE)
```


## Titanic

The `Titanic` dataset is a 4-dimensional array of counts.
First, let's convert it to a dataframe of individuals:
```{r, eval=FALSE}
titanic <- crosstabToCases(Titanic)
```

We'll specify `sameline=TRUE` so that the variable tree is a bit more compact:
```{r, eval=FALSE}
vtree(titanic,"Class Sex Age",summary="Survived=Yes \n%pct% survived",sameline=TRUE)
```


## mtcars

The `mtcars` data set was extracted from the 1974 Motor Trend US magazine,
and comprises fuel consumption and 10 aspects of automobile design and
performance for 32 automobiles (1973–74 models).

The rownames of the data set contain the names of the cars.
Let's move that information into a column.
To do that, we'll make a slightly altered version of the data frame which we'll call `mt`:

```{r, eval=FALSE}
mt <- mtcars
mt$name <- rownames(mt)
rownames(mt) <- NULL
```

Now let's look at the mean and standard deviation of horsepower (HP)
by number of carburetors, nested within number of gears,
and in turn nested within number of cylinders:

```{r, eval=FALSE}
vtree(mt,"cyl gear carb",summary="hp \nmean (SD) HP %mean% (%SD%)")
```

The above shows the mean and SD of horsepower by
(1) number of cylinders;
(2) number of gears (within number of cylinders);
and 
(3) number of carburetors (within number of gears nested within number of cylinders).
That's a lot of information.
Suppose instead that we are only interested in number 3 above,
i.e. all combinations of number of cylinders, number of gears, and number of carburetors.

In that case, we can specify `pattern=TRUE`, 
To make the display a little easier to read,
set the number of digits for the mean and SD to be zero,
and relabel the variables.

```{r, eval=FALSE}
vtree(mt,"cyl gear carb",summary="hp \nmean (SD) HP %mean% (%SD%)",
  cdigits=0,labelvar=c(cyl="# cylinders",gear="# gears",carb="# carburetors"),
  pattern=TRUE)
```

We might also like to list the names of cars by number of carburetors
nested within number of gears:

```{r, eval=FALSE}
vtree(mt,"gear carb",summary="name \n%list%%noroot%",splitwidth=50,sameline=TRUE,
  labelvar=c(gear="# gears",carb="# carburetors"))
```
  

## UCBAdmissions

The `UCBAdmissions` data is consists of aggregate data on
applicants to graduate school at Berkeley for the six largest departments in 1973
classified by admission and sex.
According to the data set Details,
"This data set is frequently used for illustrating Simpson's paradox,
see Bickel et al. (1975).
At issue is whether the data show evidence of sex bias in admission practices.
There were 2691 male applicants, of whom 1198 (44.5%) were admitted,
compared with 1835 female applicants of whom 557 (30.4%) were admitted."
Furthermore,
"the apparent association between admission and sex stems from
differences in the tendency of males and females to apply to the individual departments
(females used to apply more to departments with higher rejection rates)."

First, we'll convert the crosstab data to a data frame of cases, `ucb`:

```{r, eval=FALSE}
ucb <- crosstabToCases(UCBAdmissions)
```

Next, let's look at admission rates by Gender, nested within department:

```{r, eval=FALSE}
vtree(ucb,"Dept Gender",summary="Admit=Admitted \n%pct% admitted",sameline=TRUE)
```


## ChickWeight

The `ChickWeight` data set is from an experiment on the effect of diet on early growth of chicks.
Let's look at the mean weight of chicks at birth (0 days of age) and 4 days of age,
nested within type of diet.
A simple variable tree can be produced like this:

```{r, eval=FALSE}
vtree(ChickWeight,"Diet Time",keep=list(Time=c("0","4")),summary="weight \nmean weight %mean%g")
```

To make the display a little easier to read, relabel the nodes
and the `Time` variable:

```{r, eval=FALSE}
vtree(ChickWeight,"Diet Time",keep=list(Time=c("0","4")),
  labelnode=list(
    Diet=c("Diet 1"="1","Diet 2"="2","Diet 3"="3","Diet 4"="4"),
    Time=c("0 days"="0","4 days"="4")),
  labelvar=c(Time="Days since birth"),summary="weight \nmean weight %mean%g")
```


## InsectSprays

The `InsectSprays` data set contains
counts of insects in agricultural experimental units treated with different insecticides.
Let's look at those counts by insecticide.

```{r, eval=FALSE}
vtree(InsectSprays,"spray",splitwidth=80,sameline=TRUE,
  summary="count \ncounts: %list%%noroot%",cdigits=0)
```


## ToothGrowth

The `ToothGrowth` data set contains
the length of odontoblasts (cells responsible for tooth growth) in 60 guinea pigs.
Each animal received one of three dose levels of vitamin C (0.5, 1, and 2 mg/day)
by one of two delivery methods,
orange juice or ascorbic acid (a form of vitamin C and coded as VC).

Let's examine the percentage with length > 20 by dose nested within delivery method:

```{r, eval=FALSE}
vtree(ToothGrowth,"supp dose",summary="len>20 \n%pct% length > 20")
```

To make the display a little easier to read, relabel the nodes
and the `Time` variable:

```{r, eval=FALSE}
vtree(ToothGrowth,"supp dose",summary="len>20 \n%pct% length > 20",
  labelvar=c("supp"="Supplement type","dose"="Dose (mg/day)"),
  labelnode=list(supp=c("Vitamin C"="VC","Orange Juice"="OJ")))
```



# Generating PNG files directly

`vtree` can automatically generate PNG files when called in an
R Markdown file that is being knitted.
But you may wish to generate PNG files directly.

`vtree` uses the `DiagrammeR` package (which in turn is built on the open source graph visualization software,  `Graphviz`).
DiagrammeR (and hence `vtree`) automatically renders to HTML
using the [htmlwidgets](https://www.htmlwidgets.org/) framework
(for example, in the RStudio Viewer pane, or from R in a browser window).
However it is sometimes useful to generate a graphics file.
For example, to include a variable tree in a Microsoft Word document,
you need to create a PNG file.
Another reason to generate a PNG file is that HTML files that use `htmlwidgets` can be large,
and if they contain several widgets they can be slow to load.
The function `grVizToPNG` solves this problem by converting a variable tree into a PNG file.

## The `grVizToPNG` function

Suppose you saved the output of a call to `vtree` to an object called `example1`:

```{r, eval=FALSE}
example1 <- vtree(FakeData,"Severity Sex",pngknit=FALSE)
```

You can use `grVizToPNG` to create a PNG file called `example1.png` like this:

```{r, eval=FALSE}
grVizToPNG(example1)
```

Notes:

* The name of the graphics file (`example1.png`) is automatically derived from the name of the object (`example1`).

* The `width` or `height` arguments can be used to override the default resolution. For example, specifying `width=3000` results in a fairly high-resolution image.

* Before creating the PNG file, `grVizToPNG` first creates an SVG file. But Microsoft Word cannot handle SVG files, which is why a PNG file must be created.

* To keep things tidy, you can also specify a folder (say a subfolder of the working directory) where the PNG and SVG files will be stored. To do this, specify this argument: `folder="MyFolder"`.


## Embedding a PNG image into R Markdown output

*The steps described in this section are not usually necessary,
since `vtree` automatically embeds PNG images into R Markdown output.*

Suppose you are using R Markdown,
and wish to embed the PNG image generated by calling `grVizToPNG` into your output
(for example a Word document).
If you want the image scaled to, say, 3 inches tall, add this code inline (i.e. *not* in a code chunk):

```{r, highlight=FALSE, eval=FALSE}
![](example1.png){ height=3in }
```

If, in your call to `grVizToPNG`,
you specified that graphics files should be stored in a subfolder called `MyFolder`,
use the following code:

```{r, highlight=FALSE, eval=FALSE}
![](MyFolder/example1.png){ height=3in }
```
